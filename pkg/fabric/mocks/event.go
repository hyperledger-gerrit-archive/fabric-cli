// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/hyperledger/fabric-cli/pkg/fabric"
	"github.com/hyperledger/fabric-sdk-go/pkg/common/providers/fab"
)

type Event struct {
	RegisterBlockEventStub        func(...fab.BlockFilter) (fab.Registration, <-chan *fab.BlockEvent, error)
	registerBlockEventMutex       sync.RWMutex
	registerBlockEventArgsForCall []struct {
		arg1 []fab.BlockFilter
	}
	registerBlockEventReturns struct {
		result1 fab.Registration
		result2 <-chan *fab.BlockEvent
		result3 error
	}
	registerBlockEventReturnsOnCall map[int]struct {
		result1 fab.Registration
		result2 <-chan *fab.BlockEvent
		result3 error
	}
	RegisterChaincodeEventStub        func(string, string) (fab.Registration, <-chan *fab.CCEvent, error)
	registerChaincodeEventMutex       sync.RWMutex
	registerChaincodeEventArgsForCall []struct {
		arg1 string
		arg2 string
	}
	registerChaincodeEventReturns struct {
		result1 fab.Registration
		result2 <-chan *fab.CCEvent
		result3 error
	}
	registerChaincodeEventReturnsOnCall map[int]struct {
		result1 fab.Registration
		result2 <-chan *fab.CCEvent
		result3 error
	}
	RegisterFilteredBlockEventStub        func() (fab.Registration, <-chan *fab.FilteredBlockEvent, error)
	registerFilteredBlockEventMutex       sync.RWMutex
	registerFilteredBlockEventArgsForCall []struct {
	}
	registerFilteredBlockEventReturns struct {
		result1 fab.Registration
		result2 <-chan *fab.FilteredBlockEvent
		result3 error
	}
	registerFilteredBlockEventReturnsOnCall map[int]struct {
		result1 fab.Registration
		result2 <-chan *fab.FilteredBlockEvent
		result3 error
	}
	RegisterTxStatusEventStub        func(string) (fab.Registration, <-chan *fab.TxStatusEvent, error)
	registerTxStatusEventMutex       sync.RWMutex
	registerTxStatusEventArgsForCall []struct {
		arg1 string
	}
	registerTxStatusEventReturns struct {
		result1 fab.Registration
		result2 <-chan *fab.TxStatusEvent
		result3 error
	}
	registerTxStatusEventReturnsOnCall map[int]struct {
		result1 fab.Registration
		result2 <-chan *fab.TxStatusEvent
		result3 error
	}
	UnregisterStub        func(fab.Registration)
	unregisterMutex       sync.RWMutex
	unregisterArgsForCall []struct {
		arg1 fab.Registration
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Event) RegisterBlockEvent(arg1 ...fab.BlockFilter) (fab.Registration, <-chan *fab.BlockEvent, error) {
	fake.registerBlockEventMutex.Lock()
	ret, specificReturn := fake.registerBlockEventReturnsOnCall[len(fake.registerBlockEventArgsForCall)]
	fake.registerBlockEventArgsForCall = append(fake.registerBlockEventArgsForCall, struct {
		arg1 []fab.BlockFilter
	}{arg1})
	fake.recordInvocation("RegisterBlockEvent", []interface{}{arg1})
	fake.registerBlockEventMutex.Unlock()
	if fake.RegisterBlockEventStub != nil {
		return fake.RegisterBlockEventStub(arg1...)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.registerBlockEventReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Event) RegisterBlockEventCallCount() int {
	fake.registerBlockEventMutex.RLock()
	defer fake.registerBlockEventMutex.RUnlock()
	return len(fake.registerBlockEventArgsForCall)
}

func (fake *Event) RegisterBlockEventCalls(stub func(...fab.BlockFilter) (fab.Registration, <-chan *fab.BlockEvent, error)) {
	fake.registerBlockEventMutex.Lock()
	defer fake.registerBlockEventMutex.Unlock()
	fake.RegisterBlockEventStub = stub
}

func (fake *Event) RegisterBlockEventArgsForCall(i int) []fab.BlockFilter {
	fake.registerBlockEventMutex.RLock()
	defer fake.registerBlockEventMutex.RUnlock()
	argsForCall := fake.registerBlockEventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Event) RegisterBlockEventReturns(result1 fab.Registration, result2 <-chan *fab.BlockEvent, result3 error) {
	fake.registerBlockEventMutex.Lock()
	defer fake.registerBlockEventMutex.Unlock()
	fake.RegisterBlockEventStub = nil
	fake.registerBlockEventReturns = struct {
		result1 fab.Registration
		result2 <-chan *fab.BlockEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterBlockEventReturnsOnCall(i int, result1 fab.Registration, result2 <-chan *fab.BlockEvent, result3 error) {
	fake.registerBlockEventMutex.Lock()
	defer fake.registerBlockEventMutex.Unlock()
	fake.RegisterBlockEventStub = nil
	if fake.registerBlockEventReturnsOnCall == nil {
		fake.registerBlockEventReturnsOnCall = make(map[int]struct {
			result1 fab.Registration
			result2 <-chan *fab.BlockEvent
			result3 error
		})
	}
	fake.registerBlockEventReturnsOnCall[i] = struct {
		result1 fab.Registration
		result2 <-chan *fab.BlockEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterChaincodeEvent(arg1 string, arg2 string) (fab.Registration, <-chan *fab.CCEvent, error) {
	fake.registerChaincodeEventMutex.Lock()
	ret, specificReturn := fake.registerChaincodeEventReturnsOnCall[len(fake.registerChaincodeEventArgsForCall)]
	fake.registerChaincodeEventArgsForCall = append(fake.registerChaincodeEventArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("RegisterChaincodeEvent", []interface{}{arg1, arg2})
	fake.registerChaincodeEventMutex.Unlock()
	if fake.RegisterChaincodeEventStub != nil {
		return fake.RegisterChaincodeEventStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.registerChaincodeEventReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Event) RegisterChaincodeEventCallCount() int {
	fake.registerChaincodeEventMutex.RLock()
	defer fake.registerChaincodeEventMutex.RUnlock()
	return len(fake.registerChaincodeEventArgsForCall)
}

func (fake *Event) RegisterChaincodeEventCalls(stub func(string, string) (fab.Registration, <-chan *fab.CCEvent, error)) {
	fake.registerChaincodeEventMutex.Lock()
	defer fake.registerChaincodeEventMutex.Unlock()
	fake.RegisterChaincodeEventStub = stub
}

func (fake *Event) RegisterChaincodeEventArgsForCall(i int) (string, string) {
	fake.registerChaincodeEventMutex.RLock()
	defer fake.registerChaincodeEventMutex.RUnlock()
	argsForCall := fake.registerChaincodeEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Event) RegisterChaincodeEventReturns(result1 fab.Registration, result2 <-chan *fab.CCEvent, result3 error) {
	fake.registerChaincodeEventMutex.Lock()
	defer fake.registerChaincodeEventMutex.Unlock()
	fake.RegisterChaincodeEventStub = nil
	fake.registerChaincodeEventReturns = struct {
		result1 fab.Registration
		result2 <-chan *fab.CCEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterChaincodeEventReturnsOnCall(i int, result1 fab.Registration, result2 <-chan *fab.CCEvent, result3 error) {
	fake.registerChaincodeEventMutex.Lock()
	defer fake.registerChaincodeEventMutex.Unlock()
	fake.RegisterChaincodeEventStub = nil
	if fake.registerChaincodeEventReturnsOnCall == nil {
		fake.registerChaincodeEventReturnsOnCall = make(map[int]struct {
			result1 fab.Registration
			result2 <-chan *fab.CCEvent
			result3 error
		})
	}
	fake.registerChaincodeEventReturnsOnCall[i] = struct {
		result1 fab.Registration
		result2 <-chan *fab.CCEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterFilteredBlockEvent() (fab.Registration, <-chan *fab.FilteredBlockEvent, error) {
	fake.registerFilteredBlockEventMutex.Lock()
	ret, specificReturn := fake.registerFilteredBlockEventReturnsOnCall[len(fake.registerFilteredBlockEventArgsForCall)]
	fake.registerFilteredBlockEventArgsForCall = append(fake.registerFilteredBlockEventArgsForCall, struct {
	}{})
	fake.recordInvocation("RegisterFilteredBlockEvent", []interface{}{})
	fake.registerFilteredBlockEventMutex.Unlock()
	if fake.RegisterFilteredBlockEventStub != nil {
		return fake.RegisterFilteredBlockEventStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.registerFilteredBlockEventReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Event) RegisterFilteredBlockEventCallCount() int {
	fake.registerFilteredBlockEventMutex.RLock()
	defer fake.registerFilteredBlockEventMutex.RUnlock()
	return len(fake.registerFilteredBlockEventArgsForCall)
}

func (fake *Event) RegisterFilteredBlockEventCalls(stub func() (fab.Registration, <-chan *fab.FilteredBlockEvent, error)) {
	fake.registerFilteredBlockEventMutex.Lock()
	defer fake.registerFilteredBlockEventMutex.Unlock()
	fake.RegisterFilteredBlockEventStub = stub
}

func (fake *Event) RegisterFilteredBlockEventReturns(result1 fab.Registration, result2 <-chan *fab.FilteredBlockEvent, result3 error) {
	fake.registerFilteredBlockEventMutex.Lock()
	defer fake.registerFilteredBlockEventMutex.Unlock()
	fake.RegisterFilteredBlockEventStub = nil
	fake.registerFilteredBlockEventReturns = struct {
		result1 fab.Registration
		result2 <-chan *fab.FilteredBlockEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterFilteredBlockEventReturnsOnCall(i int, result1 fab.Registration, result2 <-chan *fab.FilteredBlockEvent, result3 error) {
	fake.registerFilteredBlockEventMutex.Lock()
	defer fake.registerFilteredBlockEventMutex.Unlock()
	fake.RegisterFilteredBlockEventStub = nil
	if fake.registerFilteredBlockEventReturnsOnCall == nil {
		fake.registerFilteredBlockEventReturnsOnCall = make(map[int]struct {
			result1 fab.Registration
			result2 <-chan *fab.FilteredBlockEvent
			result3 error
		})
	}
	fake.registerFilteredBlockEventReturnsOnCall[i] = struct {
		result1 fab.Registration
		result2 <-chan *fab.FilteredBlockEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterTxStatusEvent(arg1 string) (fab.Registration, <-chan *fab.TxStatusEvent, error) {
	fake.registerTxStatusEventMutex.Lock()
	ret, specificReturn := fake.registerTxStatusEventReturnsOnCall[len(fake.registerTxStatusEventArgsForCall)]
	fake.registerTxStatusEventArgsForCall = append(fake.registerTxStatusEventArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("RegisterTxStatusEvent", []interface{}{arg1})
	fake.registerTxStatusEventMutex.Unlock()
	if fake.RegisterTxStatusEventStub != nil {
		return fake.RegisterTxStatusEventStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.registerTxStatusEventReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *Event) RegisterTxStatusEventCallCount() int {
	fake.registerTxStatusEventMutex.RLock()
	defer fake.registerTxStatusEventMutex.RUnlock()
	return len(fake.registerTxStatusEventArgsForCall)
}

func (fake *Event) RegisterTxStatusEventCalls(stub func(string) (fab.Registration, <-chan *fab.TxStatusEvent, error)) {
	fake.registerTxStatusEventMutex.Lock()
	defer fake.registerTxStatusEventMutex.Unlock()
	fake.RegisterTxStatusEventStub = stub
}

func (fake *Event) RegisterTxStatusEventArgsForCall(i int) string {
	fake.registerTxStatusEventMutex.RLock()
	defer fake.registerTxStatusEventMutex.RUnlock()
	argsForCall := fake.registerTxStatusEventArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Event) RegisterTxStatusEventReturns(result1 fab.Registration, result2 <-chan *fab.TxStatusEvent, result3 error) {
	fake.registerTxStatusEventMutex.Lock()
	defer fake.registerTxStatusEventMutex.Unlock()
	fake.RegisterTxStatusEventStub = nil
	fake.registerTxStatusEventReturns = struct {
		result1 fab.Registration
		result2 <-chan *fab.TxStatusEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterTxStatusEventReturnsOnCall(i int, result1 fab.Registration, result2 <-chan *fab.TxStatusEvent, result3 error) {
	fake.registerTxStatusEventMutex.Lock()
	defer fake.registerTxStatusEventMutex.Unlock()
	fake.RegisterTxStatusEventStub = nil
	if fake.registerTxStatusEventReturnsOnCall == nil {
		fake.registerTxStatusEventReturnsOnCall = make(map[int]struct {
			result1 fab.Registration
			result2 <-chan *fab.TxStatusEvent
			result3 error
		})
	}
	fake.registerTxStatusEventReturnsOnCall[i] = struct {
		result1 fab.Registration
		result2 <-chan *fab.TxStatusEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) Unregister(arg1 fab.Registration) {
	fake.unregisterMutex.Lock()
	fake.unregisterArgsForCall = append(fake.unregisterArgsForCall, struct {
		arg1 fab.Registration
	}{arg1})
	fake.recordInvocation("Unregister", []interface{}{arg1})
	fake.unregisterMutex.Unlock()
	if fake.UnregisterStub != nil {
		fake.UnregisterStub(arg1)
	}
}

func (fake *Event) UnregisterCallCount() int {
	fake.unregisterMutex.RLock()
	defer fake.unregisterMutex.RUnlock()
	return len(fake.unregisterArgsForCall)
}

func (fake *Event) UnregisterCalls(stub func(fab.Registration)) {
	fake.unregisterMutex.Lock()
	defer fake.unregisterMutex.Unlock()
	fake.UnregisterStub = stub
}

func (fake *Event) UnregisterArgsForCall(i int) fab.Registration {
	fake.unregisterMutex.RLock()
	defer fake.unregisterMutex.RUnlock()
	argsForCall := fake.unregisterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *Event) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.registerBlockEventMutex.RLock()
	defer fake.registerBlockEventMutex.RUnlock()
	fake.registerChaincodeEventMutex.RLock()
	defer fake.registerChaincodeEventMutex.RUnlock()
	fake.registerFilteredBlockEventMutex.RLock()
	defer fake.registerFilteredBlockEventMutex.RUnlock()
	fake.registerTxStatusEventMutex.RLock()
	defer fake.registerTxStatusEventMutex.RUnlock()
	fake.unregisterMutex.RLock()
	defer fake.unregisterMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Event) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ fabric.Event = new(Event)
